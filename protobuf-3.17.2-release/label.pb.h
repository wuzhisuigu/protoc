// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: label.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_label_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_label_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_label_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_label_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_label_2eproto;
namespace cf {
namespace glacier {
class DefectRect;
struct DefectRectDefaultTypeInternal;
extern DefectRectDefaultTypeInternal _DefectRect_default_instance_;
class KeyPoint;
struct KeyPointDefaultTypeInternal;
extern KeyPointDefaultTypeInternal _KeyPoint_default_instance_;
class Label;
struct LabelDefaultTypeInternal;
extern LabelDefaultTypeInternal _Label_default_instance_;
class Point2f;
struct Point2fDefaultTypeInternal;
extern Point2fDefaultTypeInternal _Point2f_default_instance_;
class Polygon;
struct PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Region;
struct RegionDefaultTypeInternal;
extern RegionDefaultTypeInternal _Region_default_instance_;
class Ring;
struct RingDefaultTypeInternal;
extern RingDefaultTypeInternal _Ring_default_instance_;
class Size2f;
struct Size2fDefaultTypeInternal;
extern Size2fDefaultTypeInternal _Size2f_default_instance_;
}  // namespace glacier
}  // namespace cf
PROTOBUF_NAMESPACE_OPEN
template<> ::cf::glacier::DefectRect* Arena::CreateMaybeMessage<::cf::glacier::DefectRect>(Arena*);
template<> ::cf::glacier::KeyPoint* Arena::CreateMaybeMessage<::cf::glacier::KeyPoint>(Arena*);
template<> ::cf::glacier::Label* Arena::CreateMaybeMessage<::cf::glacier::Label>(Arena*);
template<> ::cf::glacier::Point2f* Arena::CreateMaybeMessage<::cf::glacier::Point2f>(Arena*);
template<> ::cf::glacier::Polygon* Arena::CreateMaybeMessage<::cf::glacier::Polygon>(Arena*);
template<> ::cf::glacier::Region* Arena::CreateMaybeMessage<::cf::glacier::Region>(Arena*);
template<> ::cf::glacier::Ring* Arena::CreateMaybeMessage<::cf::glacier::Ring>(Arena*);
template<> ::cf::glacier::Size2f* Arena::CreateMaybeMessage<::cf::glacier::Size2f>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cf {
namespace glacier {

enum Label_DataSetType : int {
  Label_DataSetType_Unknown = 0,
  Label_DataSetType_Segment = 1,
  Label_DataSetType_Detection = 2,
  Label_DataSetType_Classify = 3,
  Label_DataSetType_Location = 4,
  Label_DataSetType_Label_DataSetType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Label_DataSetType_Label_DataSetType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Label_DataSetType_IsValid(int value);
constexpr Label_DataSetType Label_DataSetType_DataSetType_MIN = Label_DataSetType_Unknown;
constexpr Label_DataSetType Label_DataSetType_DataSetType_MAX = Label_DataSetType_Location;
constexpr int Label_DataSetType_DataSetType_ARRAYSIZE = Label_DataSetType_DataSetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Label_DataSetType_descriptor();
template<typename T>
inline const std::string& Label_DataSetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Label_DataSetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Label_DataSetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Label_DataSetType_descriptor(), enum_t_value);
}
inline bool Label_DataSetType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Label_DataSetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Label_DataSetType>(
    Label_DataSetType_descriptor(), name, value);
}
// ===================================================================

class Point2f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cf.glacier.Point2f) */ {
 public:
  inline Point2f() : Point2f(nullptr) {}
  ~Point2f() override;
  explicit constexpr Point2f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point2f(const Point2f& from);
  Point2f(Point2f&& from) noexcept
    : Point2f() {
    *this = ::std::move(from);
  }

  inline Point2f& operator=(const Point2f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point2f& operator=(Point2f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point2f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point2f* internal_default_instance() {
    return reinterpret_cast<const Point2f*>(
               &_Point2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point2f& a, Point2f& b) {
    a.Swap(&b);
  }
  inline void Swap(Point2f* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point2f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Point2f* New() const final {
    return new Point2f();
  }

  Point2f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Point2f>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Point2f& from);
  void MergeFrom(const Point2f& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2f* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cf.glacier.Point2f";
  }
  protected:
  explicit Point2f(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kPosXFieldNumber = 3,
    kPosYFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float pos_x = 3;
  void clear_pos_x();
  float pos_x() const;
  void set_pos_x(float value);
  private:
  float _internal_pos_x() const;
  void _internal_set_pos_x(float value);
  public:

  // float pos_y = 4;
  void clear_pos_y();
  float pos_y() const;
  void set_pos_y(float value);
  private:
  float _internal_pos_y() const;
  void _internal_set_pos_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:cf.glacier.Point2f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float pos_x_;
  float pos_y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_label_2eproto;
};
// -------------------------------------------------------------------

class Size2f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cf.glacier.Size2f) */ {
 public:
  inline Size2f() : Size2f(nullptr) {}
  ~Size2f() override;
  explicit constexpr Size2f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Size2f(const Size2f& from);
  Size2f(Size2f&& from) noexcept
    : Size2f() {
    *this = ::std::move(from);
  }

  inline Size2f& operator=(const Size2f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Size2f& operator=(Size2f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Size2f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Size2f* internal_default_instance() {
    return reinterpret_cast<const Size2f*>(
               &_Size2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Size2f& a, Size2f& b) {
    a.Swap(&b);
  }
  inline void Swap(Size2f* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Size2f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Size2f* New() const final {
    return new Size2f();
  }

  Size2f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Size2f>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Size2f& from);
  void MergeFrom(const Size2f& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Size2f* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cf.glacier.Size2f";
  }
  protected:
  explicit Size2f(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // float width = 1;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 2;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:cf.glacier.Size2f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float width_;
  float height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_label_2eproto;
};
// -------------------------------------------------------------------

class DefectRect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cf.glacier.DefectRect) */ {
 public:
  inline DefectRect() : DefectRect(nullptr) {}
  ~DefectRect() override;
  explicit constexpr DefectRect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefectRect(const DefectRect& from);
  DefectRect(DefectRect&& from) noexcept
    : DefectRect() {
    *this = ::std::move(from);
  }

  inline DefectRect& operator=(const DefectRect& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefectRect& operator=(DefectRect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefectRect& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefectRect* internal_default_instance() {
    return reinterpret_cast<const DefectRect*>(
               &_DefectRect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DefectRect& a, DefectRect& b) {
    a.Swap(&b);
  }
  inline void Swap(DefectRect* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefectRect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DefectRect* New() const final {
    return new DefectRect();
  }

  DefectRect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DefectRect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DefectRect& from);
  void MergeFrom(const DefectRect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefectRect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cf.glacier.DefectRect";
  }
  protected:
  explicit DefectRect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kROIXFieldNumber = 1,
    kROIYFieldNumber = 2,
    kROIWFieldNumber = 3,
    kROIHFieldNumber = 4,
  };
  // float ROI_x = 1;
  void clear_roi_x();
  float roi_x() const;
  void set_roi_x(float value);
  private:
  float _internal_roi_x() const;
  void _internal_set_roi_x(float value);
  public:

  // float ROI_y = 2;
  void clear_roi_y();
  float roi_y() const;
  void set_roi_y(float value);
  private:
  float _internal_roi_y() const;
  void _internal_set_roi_y(float value);
  public:

  // float ROI_w = 3;
  void clear_roi_w();
  float roi_w() const;
  void set_roi_w(float value);
  private:
  float _internal_roi_w() const;
  void _internal_set_roi_w(float value);
  public:

  // float ROI_h = 4;
  void clear_roi_h();
  float roi_h() const;
  void set_roi_h(float value);
  private:
  float _internal_roi_h() const;
  void _internal_set_roi_h(float value);
  public:

  // @@protoc_insertion_point(class_scope:cf.glacier.DefectRect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float roi_x_;
  float roi_y_;
  float roi_w_;
  float roi_h_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_label_2eproto;
};
// -------------------------------------------------------------------

class KeyPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cf.glacier.KeyPoint) */ {
 public:
  inline KeyPoint() : KeyPoint(nullptr) {}
  ~KeyPoint() override;
  explicit constexpr KeyPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyPoint(const KeyPoint& from);
  KeyPoint(KeyPoint&& from) noexcept
    : KeyPoint() {
    *this = ::std::move(from);
  }

  inline KeyPoint& operator=(const KeyPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyPoint& operator=(KeyPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyPoint* internal_default_instance() {
    return reinterpret_cast<const KeyPoint*>(
               &_KeyPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(KeyPoint& a, KeyPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyPoint* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyPoint* New() const final {
    return new KeyPoint();
  }

  KeyPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyPoint& from);
  void MergeFrom(const KeyPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cf.glacier.KeyPoint";
  }
  protected:
  explicit KeyPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kLocationFieldNumber = 1,
    kScoreFieldNumber = 3,
    kAngleFieldNumber = 4,
    kRadiusFieldNumber = 5,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .cf.glacier.Point2f location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::cf::glacier::Point2f& location() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::cf::glacier::Point2f* release_location();
  ::cf::glacier::Point2f* mutable_location();
  void set_allocated_location(::cf::glacier::Point2f* location);
  private:
  const ::cf::glacier::Point2f& _internal_location() const;
  ::cf::glacier::Point2f* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::cf::glacier::Point2f* location);
  ::cf::glacier::Point2f* unsafe_arena_release_location();

  // float score = 3;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // float angle = 4;
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // float radius = 5;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:cf.glacier.KeyPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::cf::glacier::Point2f* location_;
  float score_;
  float angle_;
  float radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_label_2eproto;
};
// -------------------------------------------------------------------

class Ring final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cf.glacier.Ring) */ {
 public:
  inline Ring() : Ring(nullptr) {}
  ~Ring() override;
  explicit constexpr Ring(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ring(const Ring& from);
  Ring(Ring&& from) noexcept
    : Ring() {
    *this = ::std::move(from);
  }

  inline Ring& operator=(const Ring& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ring& operator=(Ring&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ring& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ring* internal_default_instance() {
    return reinterpret_cast<const Ring*>(
               &_Ring_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Ring& a, Ring& b) {
    a.Swap(&b);
  }
  inline void Swap(Ring* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ring* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ring* New() const final {
    return new Ring();
  }

  Ring* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ring>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ring& from);
  void MergeFrom(const Ring& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ring* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cf.glacier.Ring";
  }
  protected:
  explicit Ring(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .cf.glacier.Point2f points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::cf::glacier::Point2f* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Point2f >*
      mutable_points();
  private:
  const ::cf::glacier::Point2f& _internal_points(int index) const;
  ::cf::glacier::Point2f* _internal_add_points();
  public:
  const ::cf::glacier::Point2f& points(int index) const;
  ::cf::glacier::Point2f* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Point2f >&
      points() const;

  // @@protoc_insertion_point(class_scope:cf.glacier.Ring)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Point2f > points_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_label_2eproto;
};
// -------------------------------------------------------------------

class Polygon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cf.glacier.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {}
  ~Polygon() override;
  explicit constexpr Polygon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polygon& default_instance() {
    return *internal_default_instance();
  }
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const final {
    return new Polygon();
  }

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cf.glacier.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInnersFieldNumber = 2,
    kOuterFieldNumber = 1,
  };
  // repeated .cf.glacier.Ring inners = 2;
  int inners_size() const;
  private:
  int _internal_inners_size() const;
  public:
  void clear_inners();
  ::cf::glacier::Ring* mutable_inners(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Ring >*
      mutable_inners();
  private:
  const ::cf::glacier::Ring& _internal_inners(int index) const;
  ::cf::glacier::Ring* _internal_add_inners();
  public:
  const ::cf::glacier::Ring& inners(int index) const;
  ::cf::glacier::Ring* add_inners();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Ring >&
      inners() const;

  // .cf.glacier.Ring outer = 1;
  bool has_outer() const;
  private:
  bool _internal_has_outer() const;
  public:
  void clear_outer();
  const ::cf::glacier::Ring& outer() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::cf::glacier::Ring* release_outer();
  ::cf::glacier::Ring* mutable_outer();
  void set_allocated_outer(::cf::glacier::Ring* outer);
  private:
  const ::cf::glacier::Ring& _internal_outer() const;
  ::cf::glacier::Ring* _internal_mutable_outer();
  public:
  void unsafe_arena_set_allocated_outer(
      ::cf::glacier::Ring* outer);
  ::cf::glacier::Ring* unsafe_arena_release_outer();

  // @@protoc_insertion_point(class_scope:cf.glacier.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Ring > inners_;
  ::cf::glacier::Ring* outer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_label_2eproto;
};
// -------------------------------------------------------------------

class Region final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cf.glacier.Region) */ {
 public:
  inline Region() : Region(nullptr) {}
  ~Region() override;
  explicit constexpr Region(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Region(const Region& from);
  Region(Region&& from) noexcept
    : Region() {
    *this = ::std::move(from);
  }

  inline Region& operator=(const Region& from) {
    CopyFrom(from);
    return *this;
  }
  inline Region& operator=(Region&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Region& default_instance() {
    return *internal_default_instance();
  }
  static inline const Region* internal_default_instance() {
    return reinterpret_cast<const Region*>(
               &_Region_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Region& a, Region& b) {
    a.Swap(&b);
  }
  inline void Swap(Region* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Region* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Region* New() const final {
    return new Region();
  }

  Region* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Region>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Region& from);
  void MergeFrom(const Region& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Region* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cf.glacier.Region";
  }
  protected:
  explicit Region(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyPointsFieldNumber = 4,
    kNameFieldNumber = 2,
    kDisplayFieldNumber = 11,
    kDefectIdFieldNumber = 12,
    kString2FieldNumber = 13,
    kPolygonFieldNumber = 1,
    kScoreFieldNumber = 3,
    kAreaFieldNumber = 5,
    kDiagonalFieldNumber = 6,
    kWidthFieldNumber = 7,
    kHeightFieldNumber = 8,
    kWidthAndHeightRatioFieldNumber = 9,
    kGrayDiffFieldNumber = 10,
    kFloat1FieldNumber = 14,
    kFloat2FieldNumber = 15,
  };
  // repeated .cf.glacier.KeyPoint key_points = 4;
  int key_points_size() const;
  private:
  int _internal_key_points_size() const;
  public:
  void clear_key_points();
  ::cf::glacier::KeyPoint* mutable_key_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::KeyPoint >*
      mutable_key_points();
  private:
  const ::cf::glacier::KeyPoint& _internal_key_points(int index) const;
  ::cf::glacier::KeyPoint* _internal_add_key_points();
  public:
  const ::cf::glacier::KeyPoint& key_points(int index) const;
  ::cf::glacier::KeyPoint* add_key_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::KeyPoint >&
      key_points() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display = 11;
  void clear_display();
  const std::string& display() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_display();
  void set_allocated_display(std::string* display);
  private:
  const std::string& _internal_display() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display(const std::string& value);
  std::string* _internal_mutable_display();
  public:

  // string defectId = 12;
  void clear_defectid();
  const std::string& defectid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_defectid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_defectid();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_defectid();
  void set_allocated_defectid(std::string* defectid);
  private:
  const std::string& _internal_defectid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_defectid(const std::string& value);
  std::string* _internal_mutable_defectid();
  public:

  // string string2 = 13;
  void clear_string2();
  const std::string& string2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string2();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_string2();
  void set_allocated_string2(std::string* string2);
  private:
  const std::string& _internal_string2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string2(const std::string& value);
  std::string* _internal_mutable_string2();
  public:

  // .cf.glacier.Polygon polygon = 1;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::cf::glacier::Polygon& polygon() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::cf::glacier::Polygon* release_polygon();
  ::cf::glacier::Polygon* mutable_polygon();
  void set_allocated_polygon(::cf::glacier::Polygon* polygon);
  private:
  const ::cf::glacier::Polygon& _internal_polygon() const;
  ::cf::glacier::Polygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::cf::glacier::Polygon* polygon);
  ::cf::glacier::Polygon* unsafe_arena_release_polygon();

  // float score = 3;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // float area = 5;
  void clear_area();
  float area() const;
  void set_area(float value);
  private:
  float _internal_area() const;
  void _internal_set_area(float value);
  public:

  // float diagonal = 6;
  void clear_diagonal();
  float diagonal() const;
  void set_diagonal(float value);
  private:
  float _internal_diagonal() const;
  void _internal_set_diagonal(float value);
  public:

  // float width = 7;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 8;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // float widthAndHeightRatio = 9;
  void clear_widthandheightratio();
  float widthandheightratio() const;
  void set_widthandheightratio(float value);
  private:
  float _internal_widthandheightratio() const;
  void _internal_set_widthandheightratio(float value);
  public:

  // float grayDiff = 10;
  void clear_graydiff();
  float graydiff() const;
  void set_graydiff(float value);
  private:
  float _internal_graydiff() const;
  void _internal_set_graydiff(float value);
  public:

  // float float1 = 14;
  void clear_float1();
  float float1() const;
  void set_float1(float value);
  private:
  float _internal_float1() const;
  void _internal_set_float1(float value);
  public:

  // float float2 = 15;
  void clear_float2();
  float float2() const;
  void set_float2(float value);
  private:
  float _internal_float2() const;
  void _internal_set_float2(float value);
  public:

  // @@protoc_insertion_point(class_scope:cf.glacier.Region)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::KeyPoint > key_points_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr defectid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string2_;
  ::cf::glacier::Polygon* polygon_;
  float score_;
  float area_;
  float diagonal_;
  float width_;
  float height_;
  float widthandheightratio_;
  float graydiff_;
  float float1_;
  float float2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_label_2eproto;
};
// -------------------------------------------------------------------

class Label final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cf.glacier.Label) */ {
 public:
  inline Label() : Label(nullptr) {}
  ~Label() override;
  explicit constexpr Label(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Label(const Label& from);
  Label(Label&& from) noexcept
    : Label() {
    *this = ::std::move(from);
  }

  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }
  inline Label& operator=(Label&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Label& default_instance() {
    return *internal_default_instance();
  }
  static inline const Label* internal_default_instance() {
    return reinterpret_cast<const Label*>(
               &_Label_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Label& a, Label& b) {
    a.Swap(&b);
  }
  inline void Swap(Label* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Label* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Label* New() const final {
    return new Label();
  }

  Label* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Label>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Label& from);
  void MergeFrom(const Label& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Label* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cf.glacier.Label";
  }
  protected:
  explicit Label(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Label_DataSetType DataSetType;
  static constexpr DataSetType Unknown =
    Label_DataSetType_Unknown;
  static constexpr DataSetType Segment =
    Label_DataSetType_Segment;
  static constexpr DataSetType Detection =
    Label_DataSetType_Detection;
  static constexpr DataSetType Classify =
    Label_DataSetType_Classify;
  static constexpr DataSetType Location =
    Label_DataSetType_Location;
  static inline bool DataSetType_IsValid(int value) {
    return Label_DataSetType_IsValid(value);
  }
  static constexpr DataSetType DataSetType_MIN =
    Label_DataSetType_DataSetType_MIN;
  static constexpr DataSetType DataSetType_MAX =
    Label_DataSetType_DataSetType_MAX;
  static constexpr int DataSetType_ARRAYSIZE =
    Label_DataSetType_DataSetType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataSetType_descriptor() {
    return Label_DataSetType_descriptor();
  }
  template<typename T>
  static inline const std::string& DataSetType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataSetType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataSetType_Name.");
    return Label_DataSetType_Name(enum_t_value);
  }
  static inline bool DataSetType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DataSetType* value) {
    return Label_DataSetType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 5,
    kMasksFieldNumber = 6,
    kHardcasesFieldNumber = 7,
    kNameFieldNumber = 3,
    kDieStatusFieldNumber = 8,
    kStr1FieldNumber = 16,
    kStr2FieldNumber = 17,
    kImgSizeFieldNumber = 2,
    kDefectRECTFieldNumber = 13,
    kDatasetTypeFieldNumber = 1,
    kScoreFieldNumber = 4,
    kPartPlcPulseXFieldNumber = 9,
    kPartPlcPulseYFieldNumber = 10,
    kDieRunPosXFieldNumber = 11,
    kDieRunPosYFieldNumber = 12,
    kMeasure1FieldNumber = 14,
    kMeasure2FieldNumber = 15,
    kFlo1FieldNumber = 18,
    kFlo2FieldNumber = 19,
  };
  // repeated .cf.glacier.Region regions = 5;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  ::cf::glacier::Region* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Region >*
      mutable_regions();
  private:
  const ::cf::glacier::Region& _internal_regions(int index) const;
  ::cf::glacier::Region* _internal_add_regions();
  public:
  const ::cf::glacier::Region& regions(int index) const;
  ::cf::glacier::Region* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Region >&
      regions() const;

  // repeated .cf.glacier.Polygon masks = 6;
  int masks_size() const;
  private:
  int _internal_masks_size() const;
  public:
  void clear_masks();
  ::cf::glacier::Polygon* mutable_masks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Polygon >*
      mutable_masks();
  private:
  const ::cf::glacier::Polygon& _internal_masks(int index) const;
  ::cf::glacier::Polygon* _internal_add_masks();
  public:
  const ::cf::glacier::Polygon& masks(int index) const;
  ::cf::glacier::Polygon* add_masks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Polygon >&
      masks() const;

  // repeated .cf.glacier.Polygon hardcases = 7;
  int hardcases_size() const;
  private:
  int _internal_hardcases_size() const;
  public:
  void clear_hardcases();
  ::cf::glacier::Polygon* mutable_hardcases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Polygon >*
      mutable_hardcases();
  private:
  const ::cf::glacier::Polygon& _internal_hardcases(int index) const;
  ::cf::glacier::Polygon* _internal_add_hardcases();
  public:
  const ::cf::glacier::Polygon& hardcases(int index) const;
  ::cf::glacier::Polygon* add_hardcases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Polygon >&
      hardcases() const;

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string dieStatus = 8;
  void clear_diestatus();
  const std::string& diestatus() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_diestatus(ArgT0&& arg0, ArgT... args);
  std::string* mutable_diestatus();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_diestatus();
  void set_allocated_diestatus(std::string* diestatus);
  private:
  const std::string& _internal_diestatus() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_diestatus(const std::string& value);
  std::string* _internal_mutable_diestatus();
  public:

  // string str1 = 16;
  void clear_str1();
  const std::string& str1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str1();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_str1();
  void set_allocated_str1(std::string* str1);
  private:
  const std::string& _internal_str1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str1(const std::string& value);
  std::string* _internal_mutable_str1();
  public:

  // string str2 = 17;
  void clear_str2();
  const std::string& str2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str2();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_str2();
  void set_allocated_str2(std::string* str2);
  private:
  const std::string& _internal_str2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str2(const std::string& value);
  std::string* _internal_mutable_str2();
  public:

  // .cf.glacier.Size2f img_size = 2;
  bool has_img_size() const;
  private:
  bool _internal_has_img_size() const;
  public:
  void clear_img_size();
  const ::cf::glacier::Size2f& img_size() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::cf::glacier::Size2f* release_img_size();
  ::cf::glacier::Size2f* mutable_img_size();
  void set_allocated_img_size(::cf::glacier::Size2f* img_size);
  private:
  const ::cf::glacier::Size2f& _internal_img_size() const;
  ::cf::glacier::Size2f* _internal_mutable_img_size();
  public:
  void unsafe_arena_set_allocated_img_size(
      ::cf::glacier::Size2f* img_size);
  ::cf::glacier::Size2f* unsafe_arena_release_img_size();

  // .cf.glacier.DefectRect defectRECT = 13;
  bool has_defectrect() const;
  private:
  bool _internal_has_defectrect() const;
  public:
  void clear_defectrect();
  const ::cf::glacier::DefectRect& defectrect() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::cf::glacier::DefectRect* release_defectrect();
  ::cf::glacier::DefectRect* mutable_defectrect();
  void set_allocated_defectrect(::cf::glacier::DefectRect* defectrect);
  private:
  const ::cf::glacier::DefectRect& _internal_defectrect() const;
  ::cf::glacier::DefectRect* _internal_mutable_defectrect();
  public:
  void unsafe_arena_set_allocated_defectrect(
      ::cf::glacier::DefectRect* defectrect);
  ::cf::glacier::DefectRect* unsafe_arena_release_defectrect();

  // .cf.glacier.Label.DataSetType dataset_type = 1;
  void clear_dataset_type();
  ::cf::glacier::Label_DataSetType dataset_type() const;
  void set_dataset_type(::cf::glacier::Label_DataSetType value);
  private:
  ::cf::glacier::Label_DataSetType _internal_dataset_type() const;
  void _internal_set_dataset_type(::cf::glacier::Label_DataSetType value);
  public:

  // float score = 4;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // float Part_plc_pulse_x = 9;
  void clear_part_plc_pulse_x();
  float part_plc_pulse_x() const;
  void set_part_plc_pulse_x(float value);
  private:
  float _internal_part_plc_pulse_x() const;
  void _internal_set_part_plc_pulse_x(float value);
  public:

  // float Part_plc_pulse_y = 10;
  void clear_part_plc_pulse_y();
  float part_plc_pulse_y() const;
  void set_part_plc_pulse_y(float value);
  private:
  float _internal_part_plc_pulse_y() const;
  void _internal_set_part_plc_pulse_y(float value);
  public:

  // float Die_run_pos_x = 11;
  void clear_die_run_pos_x();
  float die_run_pos_x() const;
  void set_die_run_pos_x(float value);
  private:
  float _internal_die_run_pos_x() const;
  void _internal_set_die_run_pos_x(float value);
  public:

  // float Die_run_pos_y = 12;
  void clear_die_run_pos_y();
  float die_run_pos_y() const;
  void set_die_run_pos_y(float value);
  private:
  float _internal_die_run_pos_y() const;
  void _internal_set_die_run_pos_y(float value);
  public:

  // float Measure1 = 14;
  void clear_measure1();
  float measure1() const;
  void set_measure1(float value);
  private:
  float _internal_measure1() const;
  void _internal_set_measure1(float value);
  public:

  // float Measure2 = 15;
  void clear_measure2();
  float measure2() const;
  void set_measure2(float value);
  private:
  float _internal_measure2() const;
  void _internal_set_measure2(float value);
  public:

  // float flo1 = 18;
  void clear_flo1();
  float flo1() const;
  void set_flo1(float value);
  private:
  float _internal_flo1() const;
  void _internal_set_flo1(float value);
  public:

  // float flo2 = 19;
  void clear_flo2();
  float flo2() const;
  void set_flo2(float value);
  private:
  float _internal_flo2() const;
  void _internal_set_flo2(float value);
  public:

  // @@protoc_insertion_point(class_scope:cf.glacier.Label)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Region > regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Polygon > masks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Polygon > hardcases_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr diestatus_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str2_;
  ::cf::glacier::Size2f* img_size_;
  ::cf::glacier::DefectRect* defectrect_;
  int dataset_type_;
  float score_;
  float part_plc_pulse_x_;
  float part_plc_pulse_y_;
  float die_run_pos_x_;
  float die_run_pos_y_;
  float measure1_;
  float measure2_;
  float flo1_;
  float flo2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_label_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point2f

// float x = 1;
inline void Point2f::clear_x() {
  x_ = 0;
}
inline float Point2f::_internal_x() const {
  return x_;
}
inline float Point2f::x() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Point2f.x)
  return _internal_x();
}
inline void Point2f::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Point2f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Point2f.x)
}

// float y = 2;
inline void Point2f::clear_y() {
  y_ = 0;
}
inline float Point2f::_internal_y() const {
  return y_;
}
inline float Point2f::y() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Point2f.y)
  return _internal_y();
}
inline void Point2f::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Point2f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Point2f.y)
}

// float pos_x = 3;
inline void Point2f::clear_pos_x() {
  pos_x_ = 0;
}
inline float Point2f::_internal_pos_x() const {
  return pos_x_;
}
inline float Point2f::pos_x() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Point2f.pos_x)
  return _internal_pos_x();
}
inline void Point2f::_internal_set_pos_x(float value) {
  
  pos_x_ = value;
}
inline void Point2f::set_pos_x(float value) {
  _internal_set_pos_x(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Point2f.pos_x)
}

// float pos_y = 4;
inline void Point2f::clear_pos_y() {
  pos_y_ = 0;
}
inline float Point2f::_internal_pos_y() const {
  return pos_y_;
}
inline float Point2f::pos_y() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Point2f.pos_y)
  return _internal_pos_y();
}
inline void Point2f::_internal_set_pos_y(float value) {
  
  pos_y_ = value;
}
inline void Point2f::set_pos_y(float value) {
  _internal_set_pos_y(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Point2f.pos_y)
}

// -------------------------------------------------------------------

// Size2f

// float width = 1;
inline void Size2f::clear_width() {
  width_ = 0;
}
inline float Size2f::_internal_width() const {
  return width_;
}
inline float Size2f::width() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Size2f.width)
  return _internal_width();
}
inline void Size2f::_internal_set_width(float value) {
  
  width_ = value;
}
inline void Size2f::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Size2f.width)
}

// float height = 2;
inline void Size2f::clear_height() {
  height_ = 0;
}
inline float Size2f::_internal_height() const {
  return height_;
}
inline float Size2f::height() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Size2f.height)
  return _internal_height();
}
inline void Size2f::_internal_set_height(float value) {
  
  height_ = value;
}
inline void Size2f::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Size2f.height)
}

// -------------------------------------------------------------------

// DefectRect

// float ROI_x = 1;
inline void DefectRect::clear_roi_x() {
  roi_x_ = 0;
}
inline float DefectRect::_internal_roi_x() const {
  return roi_x_;
}
inline float DefectRect::roi_x() const {
  // @@protoc_insertion_point(field_get:cf.glacier.DefectRect.ROI_x)
  return _internal_roi_x();
}
inline void DefectRect::_internal_set_roi_x(float value) {
  
  roi_x_ = value;
}
inline void DefectRect::set_roi_x(float value) {
  _internal_set_roi_x(value);
  // @@protoc_insertion_point(field_set:cf.glacier.DefectRect.ROI_x)
}

// float ROI_y = 2;
inline void DefectRect::clear_roi_y() {
  roi_y_ = 0;
}
inline float DefectRect::_internal_roi_y() const {
  return roi_y_;
}
inline float DefectRect::roi_y() const {
  // @@protoc_insertion_point(field_get:cf.glacier.DefectRect.ROI_y)
  return _internal_roi_y();
}
inline void DefectRect::_internal_set_roi_y(float value) {
  
  roi_y_ = value;
}
inline void DefectRect::set_roi_y(float value) {
  _internal_set_roi_y(value);
  // @@protoc_insertion_point(field_set:cf.glacier.DefectRect.ROI_y)
}

// float ROI_w = 3;
inline void DefectRect::clear_roi_w() {
  roi_w_ = 0;
}
inline float DefectRect::_internal_roi_w() const {
  return roi_w_;
}
inline float DefectRect::roi_w() const {
  // @@protoc_insertion_point(field_get:cf.glacier.DefectRect.ROI_w)
  return _internal_roi_w();
}
inline void DefectRect::_internal_set_roi_w(float value) {
  
  roi_w_ = value;
}
inline void DefectRect::set_roi_w(float value) {
  _internal_set_roi_w(value);
  // @@protoc_insertion_point(field_set:cf.glacier.DefectRect.ROI_w)
}

// float ROI_h = 4;
inline void DefectRect::clear_roi_h() {
  roi_h_ = 0;
}
inline float DefectRect::_internal_roi_h() const {
  return roi_h_;
}
inline float DefectRect::roi_h() const {
  // @@protoc_insertion_point(field_get:cf.glacier.DefectRect.ROI_h)
  return _internal_roi_h();
}
inline void DefectRect::_internal_set_roi_h(float value) {
  
  roi_h_ = value;
}
inline void DefectRect::set_roi_h(float value) {
  _internal_set_roi_h(value);
  // @@protoc_insertion_point(field_set:cf.glacier.DefectRect.ROI_h)
}

// -------------------------------------------------------------------

// KeyPoint

// .cf.glacier.Point2f location = 1;
inline bool KeyPoint::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool KeyPoint::has_location() const {
  return _internal_has_location();
}
inline void KeyPoint::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::cf::glacier::Point2f& KeyPoint::_internal_location() const {
  const ::cf::glacier::Point2f* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::cf::glacier::Point2f&>(
      ::cf::glacier::_Point2f_default_instance_);
}
inline const ::cf::glacier::Point2f& KeyPoint::location() const {
  // @@protoc_insertion_point(field_get:cf.glacier.KeyPoint.location)
  return _internal_location();
}
inline void KeyPoint::unsafe_arena_set_allocated_location(
    ::cf::glacier::Point2f* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cf.glacier.KeyPoint.location)
}
inline ::cf::glacier::Point2f* KeyPoint::release_location() {
  
  ::cf::glacier::Point2f* temp = location_;
  location_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::cf::glacier::Point2f* KeyPoint::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:cf.glacier.KeyPoint.location)
  
  ::cf::glacier::Point2f* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::cf::glacier::Point2f* KeyPoint::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::cf::glacier::Point2f>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::cf::glacier::Point2f* KeyPoint::mutable_location() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.KeyPoint.location)
  return _internal_mutable_location();
}
inline void KeyPoint::set_allocated_location(::cf::glacier::Point2f* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::cf::glacier::Point2f>::GetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.KeyPoint.location)
}

// string name = 2;
inline void KeyPoint::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& KeyPoint::name() const {
  // @@protoc_insertion_point(field_get:cf.glacier.KeyPoint.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyPoint::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cf.glacier.KeyPoint.name)
}
inline std::string* KeyPoint::mutable_name() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.KeyPoint.name)
  return _internal_mutable_name();
}
inline const std::string& KeyPoint::_internal_name() const {
  return name_.Get();
}
inline void KeyPoint::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyPoint::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyPoint::release_name() {
  // @@protoc_insertion_point(field_release:cf.glacier.KeyPoint.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyPoint::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.KeyPoint.name)
}

// float score = 3;
inline void KeyPoint::clear_score() {
  score_ = 0;
}
inline float KeyPoint::_internal_score() const {
  return score_;
}
inline float KeyPoint::score() const {
  // @@protoc_insertion_point(field_get:cf.glacier.KeyPoint.score)
  return _internal_score();
}
inline void KeyPoint::_internal_set_score(float value) {
  
  score_ = value;
}
inline void KeyPoint::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:cf.glacier.KeyPoint.score)
}

// float angle = 4;
inline void KeyPoint::clear_angle() {
  angle_ = 0;
}
inline float KeyPoint::_internal_angle() const {
  return angle_;
}
inline float KeyPoint::angle() const {
  // @@protoc_insertion_point(field_get:cf.glacier.KeyPoint.angle)
  return _internal_angle();
}
inline void KeyPoint::_internal_set_angle(float value) {
  
  angle_ = value;
}
inline void KeyPoint::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:cf.glacier.KeyPoint.angle)
}

// float radius = 5;
inline void KeyPoint::clear_radius() {
  radius_ = 0;
}
inline float KeyPoint::_internal_radius() const {
  return radius_;
}
inline float KeyPoint::radius() const {
  // @@protoc_insertion_point(field_get:cf.glacier.KeyPoint.radius)
  return _internal_radius();
}
inline void KeyPoint::_internal_set_radius(float value) {
  
  radius_ = value;
}
inline void KeyPoint::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:cf.glacier.KeyPoint.radius)
}

// -------------------------------------------------------------------

// Ring

// repeated .cf.glacier.Point2f points = 1;
inline int Ring::_internal_points_size() const {
  return points_.size();
}
inline int Ring::points_size() const {
  return _internal_points_size();
}
inline void Ring::clear_points() {
  points_.Clear();
}
inline ::cf::glacier::Point2f* Ring::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Ring.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Point2f >*
Ring::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:cf.glacier.Ring.points)
  return &points_;
}
inline const ::cf::glacier::Point2f& Ring::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::cf::glacier::Point2f& Ring::points(int index) const {
  // @@protoc_insertion_point(field_get:cf.glacier.Ring.points)
  return _internal_points(index);
}
inline ::cf::glacier::Point2f* Ring::_internal_add_points() {
  return points_.Add();
}
inline ::cf::glacier::Point2f* Ring::add_points() {
  // @@protoc_insertion_point(field_add:cf.glacier.Ring.points)
  return _internal_add_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Point2f >&
Ring::points() const {
  // @@protoc_insertion_point(field_list:cf.glacier.Ring.points)
  return points_;
}

// -------------------------------------------------------------------

// Polygon

// .cf.glacier.Ring outer = 1;
inline bool Polygon::_internal_has_outer() const {
  return this != internal_default_instance() && outer_ != nullptr;
}
inline bool Polygon::has_outer() const {
  return _internal_has_outer();
}
inline void Polygon::clear_outer() {
  if (GetArenaForAllocation() == nullptr && outer_ != nullptr) {
    delete outer_;
  }
  outer_ = nullptr;
}
inline const ::cf::glacier::Ring& Polygon::_internal_outer() const {
  const ::cf::glacier::Ring* p = outer_;
  return p != nullptr ? *p : reinterpret_cast<const ::cf::glacier::Ring&>(
      ::cf::glacier::_Ring_default_instance_);
}
inline const ::cf::glacier::Ring& Polygon::outer() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Polygon.outer)
  return _internal_outer();
}
inline void Polygon::unsafe_arena_set_allocated_outer(
    ::cf::glacier::Ring* outer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outer_);
  }
  outer_ = outer;
  if (outer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cf.glacier.Polygon.outer)
}
inline ::cf::glacier::Ring* Polygon::release_outer() {
  
  ::cf::glacier::Ring* temp = outer_;
  outer_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::cf::glacier::Ring* Polygon::unsafe_arena_release_outer() {
  // @@protoc_insertion_point(field_release:cf.glacier.Polygon.outer)
  
  ::cf::glacier::Ring* temp = outer_;
  outer_ = nullptr;
  return temp;
}
inline ::cf::glacier::Ring* Polygon::_internal_mutable_outer() {
  
  if (outer_ == nullptr) {
    auto* p = CreateMaybeMessage<::cf::glacier::Ring>(GetArenaForAllocation());
    outer_ = p;
  }
  return outer_;
}
inline ::cf::glacier::Ring* Polygon::mutable_outer() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Polygon.outer)
  return _internal_mutable_outer();
}
inline void Polygon::set_allocated_outer(::cf::glacier::Ring* outer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete outer_;
  }
  if (outer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::cf::glacier::Ring>::GetOwningArena(outer);
    if (message_arena != submessage_arena) {
      outer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outer, submessage_arena);
    }
    
  } else {
    
  }
  outer_ = outer;
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Polygon.outer)
}

// repeated .cf.glacier.Ring inners = 2;
inline int Polygon::_internal_inners_size() const {
  return inners_.size();
}
inline int Polygon::inners_size() const {
  return _internal_inners_size();
}
inline void Polygon::clear_inners() {
  inners_.Clear();
}
inline ::cf::glacier::Ring* Polygon::mutable_inners(int index) {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Polygon.inners)
  return inners_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Ring >*
Polygon::mutable_inners() {
  // @@protoc_insertion_point(field_mutable_list:cf.glacier.Polygon.inners)
  return &inners_;
}
inline const ::cf::glacier::Ring& Polygon::_internal_inners(int index) const {
  return inners_.Get(index);
}
inline const ::cf::glacier::Ring& Polygon::inners(int index) const {
  // @@protoc_insertion_point(field_get:cf.glacier.Polygon.inners)
  return _internal_inners(index);
}
inline ::cf::glacier::Ring* Polygon::_internal_add_inners() {
  return inners_.Add();
}
inline ::cf::glacier::Ring* Polygon::add_inners() {
  // @@protoc_insertion_point(field_add:cf.glacier.Polygon.inners)
  return _internal_add_inners();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Ring >&
Polygon::inners() const {
  // @@protoc_insertion_point(field_list:cf.glacier.Polygon.inners)
  return inners_;
}

// -------------------------------------------------------------------

// Region

// .cf.glacier.Polygon polygon = 1;
inline bool Region::_internal_has_polygon() const {
  return this != internal_default_instance() && polygon_ != nullptr;
}
inline bool Region::has_polygon() const {
  return _internal_has_polygon();
}
inline void Region::clear_polygon() {
  if (GetArenaForAllocation() == nullptr && polygon_ != nullptr) {
    delete polygon_;
  }
  polygon_ = nullptr;
}
inline const ::cf::glacier::Polygon& Region::_internal_polygon() const {
  const ::cf::glacier::Polygon* p = polygon_;
  return p != nullptr ? *p : reinterpret_cast<const ::cf::glacier::Polygon&>(
      ::cf::glacier::_Polygon_default_instance_);
}
inline const ::cf::glacier::Polygon& Region::polygon() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.polygon)
  return _internal_polygon();
}
inline void Region::unsafe_arena_set_allocated_polygon(
    ::cf::glacier::Polygon* polygon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(polygon_);
  }
  polygon_ = polygon;
  if (polygon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cf.glacier.Region.polygon)
}
inline ::cf::glacier::Polygon* Region::release_polygon() {
  
  ::cf::glacier::Polygon* temp = polygon_;
  polygon_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::cf::glacier::Polygon* Region::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_release:cf.glacier.Region.polygon)
  
  ::cf::glacier::Polygon* temp = polygon_;
  polygon_ = nullptr;
  return temp;
}
inline ::cf::glacier::Polygon* Region::_internal_mutable_polygon() {
  
  if (polygon_ == nullptr) {
    auto* p = CreateMaybeMessage<::cf::glacier::Polygon>(GetArenaForAllocation());
    polygon_ = p;
  }
  return polygon_;
}
inline ::cf::glacier::Polygon* Region::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Region.polygon)
  return _internal_mutable_polygon();
}
inline void Region::set_allocated_polygon(::cf::glacier::Polygon* polygon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete polygon_;
  }
  if (polygon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::cf::glacier::Polygon>::GetOwningArena(polygon);
    if (message_arena != submessage_arena) {
      polygon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polygon, submessage_arena);
    }
    
  } else {
    
  }
  polygon_ = polygon;
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Region.polygon)
}

// string name = 2;
inline void Region::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Region::name() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Region::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cf.glacier.Region.name)
}
inline std::string* Region::mutable_name() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Region.name)
  return _internal_mutable_name();
}
inline const std::string& Region::_internal_name() const {
  return name_.Get();
}
inline void Region::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Region::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Region::release_name() {
  // @@protoc_insertion_point(field_release:cf.glacier.Region.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Region::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Region.name)
}

// float score = 3;
inline void Region::clear_score() {
  score_ = 0;
}
inline float Region::_internal_score() const {
  return score_;
}
inline float Region::score() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.score)
  return _internal_score();
}
inline void Region::_internal_set_score(float value) {
  
  score_ = value;
}
inline void Region::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Region.score)
}

// repeated .cf.glacier.KeyPoint key_points = 4;
inline int Region::_internal_key_points_size() const {
  return key_points_.size();
}
inline int Region::key_points_size() const {
  return _internal_key_points_size();
}
inline void Region::clear_key_points() {
  key_points_.Clear();
}
inline ::cf::glacier::KeyPoint* Region::mutable_key_points(int index) {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Region.key_points)
  return key_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::KeyPoint >*
Region::mutable_key_points() {
  // @@protoc_insertion_point(field_mutable_list:cf.glacier.Region.key_points)
  return &key_points_;
}
inline const ::cf::glacier::KeyPoint& Region::_internal_key_points(int index) const {
  return key_points_.Get(index);
}
inline const ::cf::glacier::KeyPoint& Region::key_points(int index) const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.key_points)
  return _internal_key_points(index);
}
inline ::cf::glacier::KeyPoint* Region::_internal_add_key_points() {
  return key_points_.Add();
}
inline ::cf::glacier::KeyPoint* Region::add_key_points() {
  // @@protoc_insertion_point(field_add:cf.glacier.Region.key_points)
  return _internal_add_key_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::KeyPoint >&
Region::key_points() const {
  // @@protoc_insertion_point(field_list:cf.glacier.Region.key_points)
  return key_points_;
}

// float area = 5;
inline void Region::clear_area() {
  area_ = 0;
}
inline float Region::_internal_area() const {
  return area_;
}
inline float Region::area() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.area)
  return _internal_area();
}
inline void Region::_internal_set_area(float value) {
  
  area_ = value;
}
inline void Region::set_area(float value) {
  _internal_set_area(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Region.area)
}

// float diagonal = 6;
inline void Region::clear_diagonal() {
  diagonal_ = 0;
}
inline float Region::_internal_diagonal() const {
  return diagonal_;
}
inline float Region::diagonal() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.diagonal)
  return _internal_diagonal();
}
inline void Region::_internal_set_diagonal(float value) {
  
  diagonal_ = value;
}
inline void Region::set_diagonal(float value) {
  _internal_set_diagonal(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Region.diagonal)
}

// float width = 7;
inline void Region::clear_width() {
  width_ = 0;
}
inline float Region::_internal_width() const {
  return width_;
}
inline float Region::width() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.width)
  return _internal_width();
}
inline void Region::_internal_set_width(float value) {
  
  width_ = value;
}
inline void Region::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Region.width)
}

// float height = 8;
inline void Region::clear_height() {
  height_ = 0;
}
inline float Region::_internal_height() const {
  return height_;
}
inline float Region::height() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.height)
  return _internal_height();
}
inline void Region::_internal_set_height(float value) {
  
  height_ = value;
}
inline void Region::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Region.height)
}

// float widthAndHeightRatio = 9;
inline void Region::clear_widthandheightratio() {
  widthandheightratio_ = 0;
}
inline float Region::_internal_widthandheightratio() const {
  return widthandheightratio_;
}
inline float Region::widthandheightratio() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.widthAndHeightRatio)
  return _internal_widthandheightratio();
}
inline void Region::_internal_set_widthandheightratio(float value) {
  
  widthandheightratio_ = value;
}
inline void Region::set_widthandheightratio(float value) {
  _internal_set_widthandheightratio(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Region.widthAndHeightRatio)
}

// float grayDiff = 10;
inline void Region::clear_graydiff() {
  graydiff_ = 0;
}
inline float Region::_internal_graydiff() const {
  return graydiff_;
}
inline float Region::graydiff() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.grayDiff)
  return _internal_graydiff();
}
inline void Region::_internal_set_graydiff(float value) {
  
  graydiff_ = value;
}
inline void Region::set_graydiff(float value) {
  _internal_set_graydiff(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Region.grayDiff)
}

// string display = 11;
inline void Region::clear_display() {
  display_.ClearToEmpty();
}
inline const std::string& Region::display() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.display)
  return _internal_display();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Region::set_display(ArgT0&& arg0, ArgT... args) {
 
 display_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cf.glacier.Region.display)
}
inline std::string* Region::mutable_display() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Region.display)
  return _internal_mutable_display();
}
inline const std::string& Region::_internal_display() const {
  return display_.Get();
}
inline void Region::_internal_set_display(const std::string& value) {
  
  display_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Region::_internal_mutable_display() {
  
  return display_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Region::release_display() {
  // @@protoc_insertion_point(field_release:cf.glacier.Region.display)
  return display_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Region::set_allocated_display(std::string* display) {
  if (display != nullptr) {
    
  } else {
    
  }
  display_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), display,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Region.display)
}

// string defectId = 12;
inline void Region::clear_defectid() {
  defectid_.ClearToEmpty();
}
inline const std::string& Region::defectid() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.defectId)
  return _internal_defectid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Region::set_defectid(ArgT0&& arg0, ArgT... args) {
 
 defectid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cf.glacier.Region.defectId)
}
inline std::string* Region::mutable_defectid() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Region.defectId)
  return _internal_mutable_defectid();
}
inline const std::string& Region::_internal_defectid() const {
  return defectid_.Get();
}
inline void Region::_internal_set_defectid(const std::string& value) {
  
  defectid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Region::_internal_mutable_defectid() {
  
  return defectid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Region::release_defectid() {
  // @@protoc_insertion_point(field_release:cf.glacier.Region.defectId)
  return defectid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Region::set_allocated_defectid(std::string* defectid) {
  if (defectid != nullptr) {
    
  } else {
    
  }
  defectid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), defectid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Region.defectId)
}

// string string2 = 13;
inline void Region::clear_string2() {
  string2_.ClearToEmpty();
}
inline const std::string& Region::string2() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.string2)
  return _internal_string2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Region::set_string2(ArgT0&& arg0, ArgT... args) {
 
 string2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cf.glacier.Region.string2)
}
inline std::string* Region::mutable_string2() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Region.string2)
  return _internal_mutable_string2();
}
inline const std::string& Region::_internal_string2() const {
  return string2_.Get();
}
inline void Region::_internal_set_string2(const std::string& value) {
  
  string2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Region::_internal_mutable_string2() {
  
  return string2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Region::release_string2() {
  // @@protoc_insertion_point(field_release:cf.glacier.Region.string2)
  return string2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Region::set_allocated_string2(std::string* string2) {
  if (string2 != nullptr) {
    
  } else {
    
  }
  string2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), string2,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Region.string2)
}

// float float1 = 14;
inline void Region::clear_float1() {
  float1_ = 0;
}
inline float Region::_internal_float1() const {
  return float1_;
}
inline float Region::float1() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.float1)
  return _internal_float1();
}
inline void Region::_internal_set_float1(float value) {
  
  float1_ = value;
}
inline void Region::set_float1(float value) {
  _internal_set_float1(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Region.float1)
}

// float float2 = 15;
inline void Region::clear_float2() {
  float2_ = 0;
}
inline float Region::_internal_float2() const {
  return float2_;
}
inline float Region::float2() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Region.float2)
  return _internal_float2();
}
inline void Region::_internal_set_float2(float value) {
  
  float2_ = value;
}
inline void Region::set_float2(float value) {
  _internal_set_float2(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Region.float2)
}

// -------------------------------------------------------------------

// Label

// .cf.glacier.Label.DataSetType dataset_type = 1;
inline void Label::clear_dataset_type() {
  dataset_type_ = 0;
}
inline ::cf::glacier::Label_DataSetType Label::_internal_dataset_type() const {
  return static_cast< ::cf::glacier::Label_DataSetType >(dataset_type_);
}
inline ::cf::glacier::Label_DataSetType Label::dataset_type() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.dataset_type)
  return _internal_dataset_type();
}
inline void Label::_internal_set_dataset_type(::cf::glacier::Label_DataSetType value) {
  
  dataset_type_ = value;
}
inline void Label::set_dataset_type(::cf::glacier::Label_DataSetType value) {
  _internal_set_dataset_type(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Label.dataset_type)
}

// .cf.glacier.Size2f img_size = 2;
inline bool Label::_internal_has_img_size() const {
  return this != internal_default_instance() && img_size_ != nullptr;
}
inline bool Label::has_img_size() const {
  return _internal_has_img_size();
}
inline void Label::clear_img_size() {
  if (GetArenaForAllocation() == nullptr && img_size_ != nullptr) {
    delete img_size_;
  }
  img_size_ = nullptr;
}
inline const ::cf::glacier::Size2f& Label::_internal_img_size() const {
  const ::cf::glacier::Size2f* p = img_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::cf::glacier::Size2f&>(
      ::cf::glacier::_Size2f_default_instance_);
}
inline const ::cf::glacier::Size2f& Label::img_size() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.img_size)
  return _internal_img_size();
}
inline void Label::unsafe_arena_set_allocated_img_size(
    ::cf::glacier::Size2f* img_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(img_size_);
  }
  img_size_ = img_size;
  if (img_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cf.glacier.Label.img_size)
}
inline ::cf::glacier::Size2f* Label::release_img_size() {
  
  ::cf::glacier::Size2f* temp = img_size_;
  img_size_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::cf::glacier::Size2f* Label::unsafe_arena_release_img_size() {
  // @@protoc_insertion_point(field_release:cf.glacier.Label.img_size)
  
  ::cf::glacier::Size2f* temp = img_size_;
  img_size_ = nullptr;
  return temp;
}
inline ::cf::glacier::Size2f* Label::_internal_mutable_img_size() {
  
  if (img_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::cf::glacier::Size2f>(GetArenaForAllocation());
    img_size_ = p;
  }
  return img_size_;
}
inline ::cf::glacier::Size2f* Label::mutable_img_size() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Label.img_size)
  return _internal_mutable_img_size();
}
inline void Label::set_allocated_img_size(::cf::glacier::Size2f* img_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete img_size_;
  }
  if (img_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::cf::glacier::Size2f>::GetOwningArena(img_size);
    if (message_arena != submessage_arena) {
      img_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, img_size, submessage_arena);
    }
    
  } else {
    
  }
  img_size_ = img_size;
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Label.img_size)
}

// string name = 3;
inline void Label::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Label::name() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Label::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cf.glacier.Label.name)
}
inline std::string* Label::mutable_name() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Label.name)
  return _internal_mutable_name();
}
inline const std::string& Label::_internal_name() const {
  return name_.Get();
}
inline void Label::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Label::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Label::release_name() {
  // @@protoc_insertion_point(field_release:cf.glacier.Label.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Label::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Label.name)
}

// float score = 4;
inline void Label::clear_score() {
  score_ = 0;
}
inline float Label::_internal_score() const {
  return score_;
}
inline float Label::score() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.score)
  return _internal_score();
}
inline void Label::_internal_set_score(float value) {
  
  score_ = value;
}
inline void Label::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Label.score)
}

// repeated .cf.glacier.Region regions = 5;
inline int Label::_internal_regions_size() const {
  return regions_.size();
}
inline int Label::regions_size() const {
  return _internal_regions_size();
}
inline void Label::clear_regions() {
  regions_.Clear();
}
inline ::cf::glacier::Region* Label::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Label.regions)
  return regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Region >*
Label::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:cf.glacier.Label.regions)
  return &regions_;
}
inline const ::cf::glacier::Region& Label::_internal_regions(int index) const {
  return regions_.Get(index);
}
inline const ::cf::glacier::Region& Label::regions(int index) const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.regions)
  return _internal_regions(index);
}
inline ::cf::glacier::Region* Label::_internal_add_regions() {
  return regions_.Add();
}
inline ::cf::glacier::Region* Label::add_regions() {
  // @@protoc_insertion_point(field_add:cf.glacier.Label.regions)
  return _internal_add_regions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Region >&
Label::regions() const {
  // @@protoc_insertion_point(field_list:cf.glacier.Label.regions)
  return regions_;
}

// repeated .cf.glacier.Polygon masks = 6;
inline int Label::_internal_masks_size() const {
  return masks_.size();
}
inline int Label::masks_size() const {
  return _internal_masks_size();
}
inline void Label::clear_masks() {
  masks_.Clear();
}
inline ::cf::glacier::Polygon* Label::mutable_masks(int index) {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Label.masks)
  return masks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Polygon >*
Label::mutable_masks() {
  // @@protoc_insertion_point(field_mutable_list:cf.glacier.Label.masks)
  return &masks_;
}
inline const ::cf::glacier::Polygon& Label::_internal_masks(int index) const {
  return masks_.Get(index);
}
inline const ::cf::glacier::Polygon& Label::masks(int index) const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.masks)
  return _internal_masks(index);
}
inline ::cf::glacier::Polygon* Label::_internal_add_masks() {
  return masks_.Add();
}
inline ::cf::glacier::Polygon* Label::add_masks() {
  // @@protoc_insertion_point(field_add:cf.glacier.Label.masks)
  return _internal_add_masks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Polygon >&
Label::masks() const {
  // @@protoc_insertion_point(field_list:cf.glacier.Label.masks)
  return masks_;
}

// repeated .cf.glacier.Polygon hardcases = 7;
inline int Label::_internal_hardcases_size() const {
  return hardcases_.size();
}
inline int Label::hardcases_size() const {
  return _internal_hardcases_size();
}
inline void Label::clear_hardcases() {
  hardcases_.Clear();
}
inline ::cf::glacier::Polygon* Label::mutable_hardcases(int index) {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Label.hardcases)
  return hardcases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Polygon >*
Label::mutable_hardcases() {
  // @@protoc_insertion_point(field_mutable_list:cf.glacier.Label.hardcases)
  return &hardcases_;
}
inline const ::cf::glacier::Polygon& Label::_internal_hardcases(int index) const {
  return hardcases_.Get(index);
}
inline const ::cf::glacier::Polygon& Label::hardcases(int index) const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.hardcases)
  return _internal_hardcases(index);
}
inline ::cf::glacier::Polygon* Label::_internal_add_hardcases() {
  return hardcases_.Add();
}
inline ::cf::glacier::Polygon* Label::add_hardcases() {
  // @@protoc_insertion_point(field_add:cf.glacier.Label.hardcases)
  return _internal_add_hardcases();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cf::glacier::Polygon >&
Label::hardcases() const {
  // @@protoc_insertion_point(field_list:cf.glacier.Label.hardcases)
  return hardcases_;
}

// string dieStatus = 8;
inline void Label::clear_diestatus() {
  diestatus_.ClearToEmpty();
}
inline const std::string& Label::diestatus() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.dieStatus)
  return _internal_diestatus();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Label::set_diestatus(ArgT0&& arg0, ArgT... args) {
 
 diestatus_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cf.glacier.Label.dieStatus)
}
inline std::string* Label::mutable_diestatus() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Label.dieStatus)
  return _internal_mutable_diestatus();
}
inline const std::string& Label::_internal_diestatus() const {
  return diestatus_.Get();
}
inline void Label::_internal_set_diestatus(const std::string& value) {
  
  diestatus_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Label::_internal_mutable_diestatus() {
  
  return diestatus_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Label::release_diestatus() {
  // @@protoc_insertion_point(field_release:cf.glacier.Label.dieStatus)
  return diestatus_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Label::set_allocated_diestatus(std::string* diestatus) {
  if (diestatus != nullptr) {
    
  } else {
    
  }
  diestatus_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), diestatus,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Label.dieStatus)
}

// float Part_plc_pulse_x = 9;
inline void Label::clear_part_plc_pulse_x() {
  part_plc_pulse_x_ = 0;
}
inline float Label::_internal_part_plc_pulse_x() const {
  return part_plc_pulse_x_;
}
inline float Label::part_plc_pulse_x() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.Part_plc_pulse_x)
  return _internal_part_plc_pulse_x();
}
inline void Label::_internal_set_part_plc_pulse_x(float value) {
  
  part_plc_pulse_x_ = value;
}
inline void Label::set_part_plc_pulse_x(float value) {
  _internal_set_part_plc_pulse_x(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Label.Part_plc_pulse_x)
}

// float Part_plc_pulse_y = 10;
inline void Label::clear_part_plc_pulse_y() {
  part_plc_pulse_y_ = 0;
}
inline float Label::_internal_part_plc_pulse_y() const {
  return part_plc_pulse_y_;
}
inline float Label::part_plc_pulse_y() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.Part_plc_pulse_y)
  return _internal_part_plc_pulse_y();
}
inline void Label::_internal_set_part_plc_pulse_y(float value) {
  
  part_plc_pulse_y_ = value;
}
inline void Label::set_part_plc_pulse_y(float value) {
  _internal_set_part_plc_pulse_y(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Label.Part_plc_pulse_y)
}

// float Die_run_pos_x = 11;
inline void Label::clear_die_run_pos_x() {
  die_run_pos_x_ = 0;
}
inline float Label::_internal_die_run_pos_x() const {
  return die_run_pos_x_;
}
inline float Label::die_run_pos_x() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.Die_run_pos_x)
  return _internal_die_run_pos_x();
}
inline void Label::_internal_set_die_run_pos_x(float value) {
  
  die_run_pos_x_ = value;
}
inline void Label::set_die_run_pos_x(float value) {
  _internal_set_die_run_pos_x(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Label.Die_run_pos_x)
}

// float Die_run_pos_y = 12;
inline void Label::clear_die_run_pos_y() {
  die_run_pos_y_ = 0;
}
inline float Label::_internal_die_run_pos_y() const {
  return die_run_pos_y_;
}
inline float Label::die_run_pos_y() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.Die_run_pos_y)
  return _internal_die_run_pos_y();
}
inline void Label::_internal_set_die_run_pos_y(float value) {
  
  die_run_pos_y_ = value;
}
inline void Label::set_die_run_pos_y(float value) {
  _internal_set_die_run_pos_y(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Label.Die_run_pos_y)
}

// .cf.glacier.DefectRect defectRECT = 13;
inline bool Label::_internal_has_defectrect() const {
  return this != internal_default_instance() && defectrect_ != nullptr;
}
inline bool Label::has_defectrect() const {
  return _internal_has_defectrect();
}
inline void Label::clear_defectrect() {
  if (GetArenaForAllocation() == nullptr && defectrect_ != nullptr) {
    delete defectrect_;
  }
  defectrect_ = nullptr;
}
inline const ::cf::glacier::DefectRect& Label::_internal_defectrect() const {
  const ::cf::glacier::DefectRect* p = defectrect_;
  return p != nullptr ? *p : reinterpret_cast<const ::cf::glacier::DefectRect&>(
      ::cf::glacier::_DefectRect_default_instance_);
}
inline const ::cf::glacier::DefectRect& Label::defectrect() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.defectRECT)
  return _internal_defectrect();
}
inline void Label::unsafe_arena_set_allocated_defectrect(
    ::cf::glacier::DefectRect* defectrect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(defectrect_);
  }
  defectrect_ = defectrect;
  if (defectrect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cf.glacier.Label.defectRECT)
}
inline ::cf::glacier::DefectRect* Label::release_defectrect() {
  
  ::cf::glacier::DefectRect* temp = defectrect_;
  defectrect_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::cf::glacier::DefectRect* Label::unsafe_arena_release_defectrect() {
  // @@protoc_insertion_point(field_release:cf.glacier.Label.defectRECT)
  
  ::cf::glacier::DefectRect* temp = defectrect_;
  defectrect_ = nullptr;
  return temp;
}
inline ::cf::glacier::DefectRect* Label::_internal_mutable_defectrect() {
  
  if (defectrect_ == nullptr) {
    auto* p = CreateMaybeMessage<::cf::glacier::DefectRect>(GetArenaForAllocation());
    defectrect_ = p;
  }
  return defectrect_;
}
inline ::cf::glacier::DefectRect* Label::mutable_defectrect() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Label.defectRECT)
  return _internal_mutable_defectrect();
}
inline void Label::set_allocated_defectrect(::cf::glacier::DefectRect* defectrect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete defectrect_;
  }
  if (defectrect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::cf::glacier::DefectRect>::GetOwningArena(defectrect);
    if (message_arena != submessage_arena) {
      defectrect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, defectrect, submessage_arena);
    }
    
  } else {
    
  }
  defectrect_ = defectrect;
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Label.defectRECT)
}

// float Measure1 = 14;
inline void Label::clear_measure1() {
  measure1_ = 0;
}
inline float Label::_internal_measure1() const {
  return measure1_;
}
inline float Label::measure1() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.Measure1)
  return _internal_measure1();
}
inline void Label::_internal_set_measure1(float value) {
  
  measure1_ = value;
}
inline void Label::set_measure1(float value) {
  _internal_set_measure1(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Label.Measure1)
}

// float Measure2 = 15;
inline void Label::clear_measure2() {
  measure2_ = 0;
}
inline float Label::_internal_measure2() const {
  return measure2_;
}
inline float Label::measure2() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.Measure2)
  return _internal_measure2();
}
inline void Label::_internal_set_measure2(float value) {
  
  measure2_ = value;
}
inline void Label::set_measure2(float value) {
  _internal_set_measure2(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Label.Measure2)
}

// string str1 = 16;
inline void Label::clear_str1() {
  str1_.ClearToEmpty();
}
inline const std::string& Label::str1() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.str1)
  return _internal_str1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Label::set_str1(ArgT0&& arg0, ArgT... args) {
 
 str1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cf.glacier.Label.str1)
}
inline std::string* Label::mutable_str1() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Label.str1)
  return _internal_mutable_str1();
}
inline const std::string& Label::_internal_str1() const {
  return str1_.Get();
}
inline void Label::_internal_set_str1(const std::string& value) {
  
  str1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Label::_internal_mutable_str1() {
  
  return str1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Label::release_str1() {
  // @@protoc_insertion_point(field_release:cf.glacier.Label.str1)
  return str1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Label::set_allocated_str1(std::string* str1) {
  if (str1 != nullptr) {
    
  } else {
    
  }
  str1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), str1,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Label.str1)
}

// string str2 = 17;
inline void Label::clear_str2() {
  str2_.ClearToEmpty();
}
inline const std::string& Label::str2() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.str2)
  return _internal_str2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Label::set_str2(ArgT0&& arg0, ArgT... args) {
 
 str2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cf.glacier.Label.str2)
}
inline std::string* Label::mutable_str2() {
  // @@protoc_insertion_point(field_mutable:cf.glacier.Label.str2)
  return _internal_mutable_str2();
}
inline const std::string& Label::_internal_str2() const {
  return str2_.Get();
}
inline void Label::_internal_set_str2(const std::string& value) {
  
  str2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Label::_internal_mutable_str2() {
  
  return str2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Label::release_str2() {
  // @@protoc_insertion_point(field_release:cf.glacier.Label.str2)
  return str2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Label::set_allocated_str2(std::string* str2) {
  if (str2 != nullptr) {
    
  } else {
    
  }
  str2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), str2,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:cf.glacier.Label.str2)
}

// float flo1 = 18;
inline void Label::clear_flo1() {
  flo1_ = 0;
}
inline float Label::_internal_flo1() const {
  return flo1_;
}
inline float Label::flo1() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.flo1)
  return _internal_flo1();
}
inline void Label::_internal_set_flo1(float value) {
  
  flo1_ = value;
}
inline void Label::set_flo1(float value) {
  _internal_set_flo1(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Label.flo1)
}

// float flo2 = 19;
inline void Label::clear_flo2() {
  flo2_ = 0;
}
inline float Label::_internal_flo2() const {
  return flo2_;
}
inline float Label::flo2() const {
  // @@protoc_insertion_point(field_get:cf.glacier.Label.flo2)
  return _internal_flo2();
}
inline void Label::_internal_set_flo2(float value) {
  
  flo2_ = value;
}
inline void Label::set_flo2(float value) {
  _internal_set_flo2(value);
  // @@protoc_insertion_point(field_set:cf.glacier.Label.flo2)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace glacier
}  // namespace cf

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::cf::glacier::Label_DataSetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cf::glacier::Label_DataSetType>() {
  return ::cf::glacier::Label_DataSetType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_label_2eproto
